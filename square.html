<!DOCTYPE html><html lang="fr">
	<head><meta charset="utf-8"/><link rel="stylesheet" href="css/stylesheet.css">
	<script src="js/commonFunctions.js"></script>
	<script src="js/gl-matrix-min.js"></script>
	<script src="js/webglTools.js"></script>
	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;

		uniform float uRadius;
		uniform float uCx;
		uniform float uCy;
		uniform float uWidth;
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;

		varying vec3 pos;
		varying float vRadius;
		varying float vCx;
		varying float vCy;
		varying float vWidth;

		void main(void){
			pos=aVertexPosition;
			vRadius = uRadius;
			vCx = uCx;
			vCy = uCy;
			vWidth = uWidth;
			gl_PointSize = 5.0;
			gl_Position=uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		}
	</script>

	<script id="shader-fs" type="x-shader/x-fragment">
		#ifdef GL_ES
		precision highp float;
		#endif
		varying vec3 pos;
		varying float vRadius;
		varying float vCx;
		varying float vCy;
		varying float vWidth;

		void main(void){
			float fRadius = vRadius;
			float fWidth = vWidth;
			vec2 center = vec2( vCx, vCy );
			if((pos.x>center.x-fRadius && pos.x<center.x+fRadius) && (pos.y<center.y+fRadius && pos.y>center.y-fRadius)){
				if((pos.x>center.x-fRadius+fWidth && pos.x<center.x+fRadius-fWidth) && (pos.y>center.y-fRadius+fWidth && pos.y<center.y+fRadius-fWidth)){
					gl_FragColor=vec4(0.0,0.0,0.0,1.0);
				}
				else{
					gl_FragColor=vec4(1.0,1.0,1.0,1.0);
				}
			}else{
				gl_FragColor=vec4(0.0,0.0,0.0,1.0);
			}
		}
	</script>

	<script>
		var centerX = 0.0;
		var centerY = 0.0;
		var squareRadius = 0.5; // 50%
		var squareWidth = 0.02;

		var vertexBuffer=null;
		var indexBuffer=null;
		var indices=[];
		var vertices=[];
		var mvMatrix=mat4.create();
		var pMatrix=mat4.create();
		function initShaderParameters(prg){
			prg.vertexPositionAttribute=glContext.getAttribLocation(prg, "aVertexPosition");
			glContext.enableVertexAttribArray(prg.vertexPositionAttribute);

			prg.radiusUniform = glContext.getUniformLocation(prg, "uRadius");
			prg.centerXUniform = glContext.getUniformLocation(prg, "uCx");
			prg.centerYUniform = glContext.getUniformLocation(prg, "uCy");
			prg.squareWidthUniform = glContext.getUniformLocation(prg, "uWidth");

			prg.pMatrixUniform=glContext.getUniformLocation(prg, 'uPMatrix');
			prg.mvMatrixUniform=glContext.getUniformLocation(prg, 'uMVMatrix');
		}
		function drawSquares(){
			//vertices.push(centerX, centerY, 0.0);
			//indices.push(0);
			var sceneBegin=-1;
			var squareSize=2;
			vertices.push(sceneBegin, sceneBegin, 0.0);
			vertices.push(sceneBegin+squareSize, sceneBegin, 0.0);
			vertices.push(sceneBegin, sceneBegin+squareSize, 0.0);
			vertices.push(sceneBegin+squareSize, sceneBegin+squareSize, 0.0);
			indices.push(0, 1, 2, 1, 2, 3);
		}
		function initBuffers(){
			drawSquares();

			vertexBuffer=getVertexBufferWithVertices(vertices);
			indexBuffer=getIndexBufferWithIndices(indices);
		}
		function drawScene(){
				glContext.clearColor(0.9, 0.9, 0.9, 1.0);
				glContext.enable(glContext.DEPTH_TEST);
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				glContext.viewport(0, 0, c_width, c_height);
				mat4.identity(pMatrix);
				mat4.identity(mvMatrix);

				glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
				glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

				glContext.uniform1f(prg.radiusUniform, squareRadius);
				glContext.uniform1f(prg.centerXUniform, centerX);
				glContext.uniform1f(prg.centerYUniform, centerY);
				glContext.uniform1f(prg.squareWidthUniform, squareWidth);

				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);

				glContext.drawElements(glContext.TRIANGLES, indices.length, glContext.UNSIGNED_SHORT, 0);

			}

		function initWebGL(){
			glContext=getGLContext('webgl-canvas');
			initProgram();
			initBuffers();
			renderLoop();
		}

		function sliderRadiusChanged(){
			squareRadius = document.getElementById("sliderRayon").value / 100.0;
		}
		function sliderWidthChanged(){
			squareWidth = document.getElementById("sliderEpaisseur").value / 1000.0;
		}

		</script>
	</head>

	<body onload="initWebGL()">
		<script>
			displayTitle("Labo 1 - Équipe A3", "INF3dlma - Jonas Freiburghaus, Vincent Moulin et Romain Capocasale");

		</script>

		<div style="margin-left: 20px;">
            <br>Un carré blanc

            <br /><br />Rayon : <input type="range" id="sliderRayon" value="50" min="0" max="100" oninput="sliderRadiusChanged();">
            <br />Epaisseur : <input type="range" id="sliderEpaisseur" value="20" min="0" max="100" oninput="sliderWidthChanged();">
            <br />Centre : cliquer sur le canevas

            <br /><canvas id="webgl-canvas" width="500" height="500">HTML5 is not supported</canvas>
        </div>
	</body>

	<script id='code-js' type="text/javascript">
		var myCanvas = document.getElementById('webgl-canvas');
		myCanvas.addEventListener('click', function(evt) {
			var mousePos = getMousePos(myCanvas, evt);
			centerX = (mousePos.x - myCanvas.width/2.0) / myCanvas.width * 2.0;
			centerY = (myCanvas.height/2.0 - mousePos.y) / myCanvas.height * 2.0;
			/*vertices = [];
			vertices.push(centerX, centerY, 0.0);
			initBuffers();*/
		}, false);
		function getMousePos(myCanvas, evt) {
			var rect = myCanvas.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left,
				y: evt.clientY - rect.top
			};
		}
	</script>
</html>
